// Copyright 2019 kdevb0x Ltd. All rights reserved.
// Use of this source code is governed by the BSD 3-Clause license
// The full license text can be found in the LICENSE file.

package credfilecrypt

import (
	"fmt"
	"os"
	"crypto"
	"io"
	"io/ioutil"
	"encoding/hex"

	"golang.org/x/crypto/bcrypt"
	"github.com/spf13/pflag"
)

var uname = (credfileLen() % 2) > 0
var pword = (credfileLen() % 2) == 0

var (
	fileflag        = pflag.StringP("credfile", "f", "", "encrypted csv file containing credentials")
	createfileflag  = pflag.BoolP("create", "c", false, "create the credfile at path indicated by -f")
	createfileforce = pflag.Bool("force", false, "force overwrite of existing file on --create")
	create = pflag.NewFlagSet()
)

type CredFile struct {
	f *os.File
	Format *CredFileRecord
	sealed bool
	enclaveBuffer []byte
}

type EncryptedStater interface {
	// EncryptedState should return the current encrypted state.
	// implementations should return true if in ciphertext (encrypted),
	// or false if in cleartext (unencrypted) state.
	EncryptedState() bool
}

type CredFileRecord struct {
	// where account exists. ex "google" for mail.google.com
	domain string `json:"host_domain"`

	// ex: "example@gmail.com"
	accountEmail string `json:"email"`

	// The password string generated by passgen utility
	generatedPass string `json:"passgen_string"`
}

func opencredfile(file string) (*CredFile, error) {
	var f *CredFile
	f.f, err := os.OpenFile(file, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0666)
	if err != nil {
		// TODO: refactor this out into its own function
		if os.IsExist(err) {
			if *createfileflag {
				if !*createfileforce {
					return nil, fmt.Errorf("cannot create file %s, it already exists! (pass --force to force overwrite)", file)
				}
				if err := os.Remove(file); err != nil {

				}
				nf, _ := os.Create(file)
				// have to do this because this lays inside 'return nil, err'
				f = nf
				return f, nil
			}
		}
		return nil, err
	}
	p := &credfile{file: f}
	return p, nil
}

func (f *CredFile) Close() error {
	return f.Close()
	// TODO: refactor this out into its own function
}

func (f *CredFile) Open(password []byte) error {
	bcrypt.CompareHashAndPassword()
	n, err := f.UnmarshalHex(f.enclaveBuffer)
	if err != nil {
		return err
	}
	
}

func (f *CredFile) EncryptedState() bool {
	return f.sealed
}

func (f *CredFile) unmarshalHex(b []byte) (n int, err error) {
	return io.ReadFull(f.f, b)

}

func main() {
	pflag.Parse()
}
